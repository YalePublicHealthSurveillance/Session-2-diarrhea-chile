---
title: "chile-aberration"
author: "Dan Weinberger"
date: "February 4, 2019"
output:
  word_document: default
  html_document: default
---

##Getting started
1) Save this .Rmd file and any data files (e.g., .csv files) in the same directory
2) Make sure you have the packages installed listed in the chunk below


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(surveillance)
library(lubridate)
library(ggplot2)
library(shiny)
library(zoo)

source('./R/App_Hist_limit.R')
source('./R/FarringtonApp.R')
source('./R/glrpoisApp.R')
source('./R/surv.ds.convert.R')
```

##Goal for the exercise

Today, we will set up an aberration detection algorithm for diarrheal disease among children <5y in Chile (population 18 Million). We will first format and explore the data and will then  test out a few different algorithms and decide on the most appropriate. Administrative hospitalization data for Chile are publicly available on the Ministry of Health Website. Variables included in this parsed down database are:

EDAD: age in years
diag1: primary diagnosis, in ICD10 coding
date: Date admitted to hospital 

You have been provided with a subset of the larger database that includes ICD10 codes that start with the letter "A" (certain infectious diseases). We can learn more about the ICD10 codes here: https://www.icd10data.com/ICD10CM/Codes/A00-B99

### First read in the data 

```{r readscsv}
d1<-read.csv('./Data/chile_under5y_aCHAPTER.csv')
```

## Tell R that 'date' is a date variable and assign a format

see https://www.statmethods.net/input/dates.html
The data are initially in the format day f the month, 3 digit month, 4 difit year. We need to convert this to a date format in R. 

```{r date_format}
d1$date[1:10]
```

We can do this with a as.Date function in R. %d means 2 digit day of month, %b means we have a 3 digit month, and %Y means we have a 4 digit month. If you had a 2 digit date, you would use a lower case y. If you had dashes or slashed, you would include them in he format statement. For instance 01-Dec-2010 would be "%d-%b-%Y". Or if you had 01/12/19 (day/month/year), the format would be "%d/%m/%y" (note the lower case y because it is a 2 digit month)
```{r}
d1$date<- as.Date(d1$date, format="%d%b%Y")
d1$date[1:10]
```

Then create a new variable called 'week.date' that has the date of the Sunday of the week in which the admission occurred. The lubridate has some functions that make this easier. You want to round the date down to the nearest Sunday. The floor_data function can accomplish this: https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf

```{r date_format2}
#"round" the date down to 
d1$week.date <- floor_date(d1$date, unit='week')
```


### Then do some basic explorations. What is the distibution of ages? of Dates? (make a histogram for each)
```{r hist1}
hist(d1$EDAD)
```

```{r}
hist(d1$date, breaks=10)
```


### Which ICD10 codes are the most commonly used in this databse?
Make a table of the codes, sorted most to least common. To figure out what these codes mean, look at an ICD10 dictionary online like  https://www.icd10data.com/ICD10CM/Codes/A00-B99

```{r freq.codes, echo=FALSE}
sort(table(d1$diag1),decreasing=T)[1:50]
```

It is sometimes more useful to look at broader categories. You can do this by looking at the first 3 digits of the ICD10 code
```{r}

icd10.3digits<-substr(d1$diag1,1,3) #extract 1st 3 digits from IC10 code

icd10.3digits[1:10] #view first 10

```
Look at their frequency
```{r}
sort(table(icd10.3digits),decreasing=T)

```

Now create flags for diarrheal disease codes (A00-A09)
```{r}
#Initialize variables
d1$a00_a09<-rep(0, nrow(d1))
d1$a00_a09[icd10.3digits %in% c('A00', 'A01', 'A02', 'A03', 'A04', 'A05', 'A06', 'A07', 'A08', 'A09') ]<-1
```

#Check your work
```{r}
table(d1$a00_a09, d1$diag1) 
```

## Let's aggregate the A00-A09 codes by week.date

```{r}

d2<-aggregate(d1[,'a00_a09'],  #which variable(s) do you want to aggregate?
              by=list('week.date'=d1$week.date),  #by which variable(s) do you want to aggregate?
              FUN=sum) #function you want to use (you could also take mean by week if you wanted)

names(d2)<-c('week.date','a00_a09') #renames the columns
```

It is  important to make sure that the time series is 'filled'--if there are weeks with 0 counts, it needs to be represented in the time series. to do this, let's make a vector of week.dates and see if it is of the length as our data
```{r}
dates<- d2$week.date
date.seq <- seq.Date(from=dates[1], to=dates[length(dates)], by='week') #create a sequence from first to last week date
length(dates)==length(date.seq) #test if the time series is complete
```

OK, so we have all week represented. If this was FALSE (some weeks were not represented), we would need to fill it. An easy way to do this is to create another dataframe that has all dates represented (and if you have multiple age groups, would have all dates for all age groups represented). Then merge that back in with your original data
```{r}
#data frame 1 has just the time series with all weeks represented 
date.seq<-as.data.frame(date.seq)
names(date.seq)<-'week.date' #make sure column name is 'date'

#Merge together the empty dataset with just the dates and the original data
d4<- merge(d2, date.seq, all=T, by='week.date')
names(d4)<-c('week.date', 'a00_a09')

#for any weeks that were not present in original data, assign a count of 0.
d4$a00_a09[is.na(d4$a00_a09)] <- 0

#write.csv(d4,'d4.csv') #can save a copy of the dataset if you want

```

*Dataset d4 will be used in all further analyses. If you got stuck prior to this, go ahead and read in and use the pre-formatted dataset 'd4.csv'*
```{r}
#d4<- read.csv('d4.csv') #Only run this if you were not able to complete previous steps
```


```{r}
plot(d4$week.date, d4$a00_a09, type='l', bty='l', ylab='Cases A00-A09')
```

OK for now let's pretend that we want to detect aberrations in 2009. We can subset the data to only include dates through end of 2009
```{r}
d5<-d4[d4$week.date<=as.Date('2007-12-31'),]
```


Plot the time series

```{r}
p1 <- ggplot(d5 , aes(x=week.date, y=a00_a09)) +
  geom_line() +
  theme_classic() 

p1 
```


## Now let's test this out in the surveillance package
Need to determine the year and week of the first data Can use week(date) and year(date) functions to do this

```{r}
# a00_DP <- create.disProg(
#       week = 1:nrow(d5), #Index of observations
#       observed = d5$a00_a09 ,
#       state=matrix(0, nrow=nrow(d4), ncol=1),
#       start = c(2000, 53))
```

Let's look for aberrations during the 2007 calendar years first, then see how it performs for 2008-2011 Need to  first determine indexes for thise year

Let's try historical limits with default threshold

QUESTIONS to consider
1. What happens if use adjust alpha up or down?
2. What happens if you include fewer or more 4 week periods on either side?


```{r}
app.hist.limit(ds=d5, datevar='week.date', casevar='a00_a09')

```


Let's try Farrington method, with and without down-weighting past epidemics
QUESTIONS to consider
1. There is a drop in cases apparent in the data in the last couple of years. How does this affect the algorithms?
2. How important is the reweighting option for the Farrington algorithm?
3. What happens if use more or fewer years of histrical data for Farrington?



```{r hist.limits2}
FarringtonApp(ds=d5, datevar='week.date', casevar='a00_a09')
```

Ok let's look forward now a
QUESTIONS to consider
1. There is a drop in cases apparent in the data in the last couple of years. How does this affect the algorithms?
2. How important is the reweighting for the Farrington algorithm?
3. What happens if use more or fewer years of historical data for Farrington?


## Control chart methods

```{r}
glrpois_App(ds=d5, datevar='week.date', casevar='a00_a09', n.weeks.train=53)

```



